#!/usr/bin/env python3\n\"\"\"\nC/ua Performance Monitor\n\nComprehensive performance monitoring service for C/ua framework integration.\nMonitors system resources, service health, and performance metrics.\n\nFeatures:\n- Real-time system resource monitoring\n- Service health checks and availability tracking\n- Performance metrics collection and analysis\n- Automated alerting for performance issues\n- Integration with C/ua framework services\n\nAuthor: Claude Code\nVersion: 1.0.0\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport psutil\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, asdict\nfrom fastapi import FastAPI, HTTPException\nimport uvicorn\nimport aiohttp\nimport argparse\n\n# === Configuration ===\n\n@dataclass\nclass MonitorConfig:\n    \"\"\"Configuration for performance monitoring\"\"\"\n    monitor_interval: int = 10  # seconds\n    metrics_retention_days: int = 7\n    log_level: str = \"INFO\"\n    log_file: str = \"/opt/monitoring/logs/monitor.log\"\n    metrics_file: str = \"/opt/monitoring/metrics/performance.json\"\n    ane_bridge_url: str = \"http://host.docker.internal:8080\"\n    alert_webhook_url: Optional[str] = None\n    port: int = 9995\n    \n@dataclass\nclass SystemMetrics:\n    \"\"\"System resource metrics\"\"\"\n    timestamp: str\n    cpu_usage: float\n    memory_usage: float\n    memory_total: int\n    memory_available: int\n    disk_usage: float\n    disk_total: int\n    disk_free: int\n    load_average: List[float]\n    network_io: Dict[str, int]\n    \n@dataclass\nclass ServiceHealth:\n    \"\"\"Service health status\"\"\"\n    service_name: str\n    healthy: bool\n    response_time: float\n    last_check: str\n    error_message: Optional[str] = None\n\n# === Performance Monitor Class ===\n\nclass PerformanceMonitor:\n    \"\"\"Main performance monitoring service\"\"\"\n    \n    def __init__(self, config: MonitorConfig):\n        self.config = config\n        self.logger = self._setup_logging()\n        self.metrics_history: List[SystemMetrics] = []\n        self.service_health: Dict[str, ServiceHealth] = {}\n        self.app = FastAPI(title=\"C/ua Performance Monitor\", version=\"1.0.0\")\n        self.setup_routes()\n        \n        # Services to monitor\n        self.services = {\n            \"bytebotd\": \"http://localhost:9990/\",\n            \"cua_agent\": \"http://localhost:9993/api/v1/health\",\n            \"ane_bridge\": f\"{config.ane_bridge_url}/health\",\n            \"websocket_server\": \"http://localhost:9996/health\"\n        }\n        \n        self.logger.info(f\"Performance Monitor initialized - Port: {config.port}\")\n    \n    def _setup_logging(self) -> logging.Logger:\n        \"\"\"Setup structured logging\"\"\"\n        logger = logging.getLogger(\"cua_performance_monitor\")\n        logger.setLevel(getattr(logging, self.config.log_level.upper()))\n        \n        # Create log directory if it doesn't exist\n        log_path = Path(self.config.log_file)\n        log_path.parent.mkdir(parents=True, exist_ok=True)\n        \n        # File handler with rotation\n        handler = logging.FileHandler(self.config.log_file)\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        \n        return logger\n    \n    def setup_routes(self):\n        \"\"\"Setup FastAPI routes for monitoring API\"\"\"\n        \n        @self.app.get(\"/\")\n        async def root():\n            return {\"service\": \"C/ua Performance Monitor\", \"status\": \"running\"}\n        \n        @self.app.get(\"/health\")\n        async def health_check():\n            return {\n                \"status\": \"healthy\",\n                \"timestamp\": datetime.now().isoformat(),\n                \"uptime\": time.time() - self.start_time\n            }\n        \n        @self.app.get(\"/metrics\")\n        async def get_metrics():\n            \"\"\"Get current system metrics\"\"\"\n            current_metrics = await self.collect_system_metrics()\n            return asdict(current_metrics)\n        \n        @self.app.get(\"/metrics/history\")\n        async def get_metrics_history(hours: int = 1):\n            \"\"\"Get metrics history for specified hours\"\"\"\n            cutoff_time = datetime.now() - timedelta(hours=hours)\n            cutoff_str = cutoff_time.isoformat()\n            \n            filtered_metrics = [\n                asdict(m) for m in self.metrics_history\n                if m.timestamp >= cutoff_str\n            ]\n            \n            return {\n                \"timeframe_hours\": hours,\n                \"metrics_count\": len(filtered_metrics),\n                \"metrics\": filtered_metrics\n            }\n        \n        @self.app.get(\"/services\")\n        async def get_service_health():\n            \"\"\"Get health status of all monitored services\"\"\"\n            return {\n                service_name: asdict(health)\n                for service_name, health in self.service_health.items()\n            }\n        \n        @self.app.get(\"/alerts\")\n        async def get_alerts():\n            \"\"\"Get current system alerts\"\"\"\n            alerts = await self.check_performance_alerts()\n            return {\n                \"timestamp\": datetime.now().isoformat(),\n                \"alerts\": alerts\n            }\n    \n    async def collect_system_metrics(self) -> SystemMetrics:\n        \"\"\"Collect current system resource metrics\"\"\"\n        # CPU usage\n        cpu_usage = psutil.cpu_percent(interval=1)\n        \n        # Memory usage\n        memory = psutil.virtual_memory()\n        \n        # Disk usage for root filesystem\n        disk = psutil.disk_usage('/')\n        \n        # Load average\n        load_avg = os.getloadavg() if hasattr(os, 'getloadavg') else [0, 0, 0]\n        \n        # Network I/O\n        network_io = psutil.net_io_counters()\n        network_stats = {\n            \"bytes_sent\": network_io.bytes_sent,\n            \"bytes_recv\": network_io.bytes_recv,\n            \"packets_sent\": network_io.packets_sent,\n            \"packets_recv\": network_io.packets_recv\n        }\n        \n        return SystemMetrics(\n            timestamp=datetime.now().isoformat(),\n            cpu_usage=cpu_usage,\n            memory_usage=memory.percent,\n            memory_total=memory.total,\n            memory_available=memory.available,\n            disk_usage=(disk.used / disk.total) * 100,\n            disk_total=disk.total,\n            disk_free=disk.free,\n            load_average=list(load_avg),\n            network_io=network_stats\n        )\n    \n    async def check_service_health(self) -> Dict[str, ServiceHealth]:\n        \"\"\"Check health of all monitored services\"\"\"\n        health_results = {}\n        \n        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:\n            for service_name, service_url in self.services.items():\n                start_time = time.time()\n                \n                try:\n                    async with session.get(service_url) as response:\n                        response_time = time.time() - start_time\n                        healthy = response.status < 500\n                        \n                        health_results[service_name] = ServiceHealth(\n                            service_name=service_name,\n                            healthy=healthy,\n                            response_time=response_time,\n                            last_check=datetime.now().isoformat(),\n                            error_message=None if healthy else f\"HTTP {response.status}\"\n                        )\n                        \n                except Exception as error:\n                    response_time = time.time() - start_time\n                    health_results[service_name] = ServiceHealth(\n                        service_name=service_name,\n                        healthy=False,\n                        response_time=response_time,\n                        last_check=datetime.now().isoformat(),\n                        error_message=str(error)\n                    )\n        \n        return health_results\n    \n    async def check_performance_alerts(self) -> List[Dict[str, Any]]:\n        \"\"\"Check for performance alerts based on thresholds\"\"\"\n        alerts = []\n        \n        # Get latest metrics\n        if not self.metrics_history:\n            return alerts\n        \n        latest = self.metrics_history[-1]\n        \n        # CPU usage alert\n        if latest.cpu_usage > 80:\n            alerts.append({\n                \"type\": \"high_cpu_usage\",\n                \"severity\": \"warning\" if latest.cpu_usage < 90 else \"critical\",\n                \"message\": f\"High CPU usage: {latest.cpu_usage:.1f}%\",\n                \"value\": latest.cpu_usage,\n                \"threshold\": 80,\n                \"timestamp\": latest.timestamp\n            })\n        \n        # Memory usage alert\n        if latest.memory_usage > 85:\n            alerts.append({\n                \"type\": \"high_memory_usage\",\n                \"severity\": \"warning\" if latest.memory_usage < 95 else \"critical\",\n                \"message\": f\"High memory usage: {latest.memory_usage:.1f}%\",\n                \"value\": latest.memory_usage,\n                \"threshold\": 85,\n                \"timestamp\": latest.timestamp\n            })\n        \n        # Disk usage alert\n        if latest.disk_usage > 90:\n            alerts.append({\n                \"type\": \"high_disk_usage\",\n                \"severity\": \"warning\" if latest.disk_usage < 95 else \"critical\",\n                \"message\": f\"High disk usage: {latest.disk_usage:.1f}%\",\n                \"value\": latest.disk_usage,\n                \"threshold\": 90,\n                \"timestamp\": latest.timestamp\n            })\n        \n        # Service health alerts\n        unhealthy_services = [\n            service_name for service_name, health in self.service_health.items()\n            if not health.healthy\n        ]\n        \n        if unhealthy_services:\n            alerts.append({\n                \"type\": \"unhealthy_services\",\n                \"severity\": \"critical\" if \"bytebotd\" in unhealthy_services else \"warning\",\n                \"message\": f\"Unhealthy services: {', '.join(unhealthy_services)}\",\n                \"services\": unhealthy_services,\n                \"timestamp\": datetime.now().isoformat()\n            })\n        \n        return alerts\n    \n    async def save_metrics(self):\n        \"\"\"Save metrics to file for persistence\"\"\"\n        try:\n            metrics_path = Path(self.config.metrics_file)\n            metrics_path.parent.mkdir(parents=True, exist_ok=True)\n            \n            # Keep only recent metrics based on retention policy\n            cutoff_time = datetime.now() - timedelta(days=self.config.metrics_retention_days)\n            cutoff_str = cutoff_time.isoformat()\n            \n            recent_metrics = [\n                asdict(m) for m in self.metrics_history\n                if m.timestamp >= cutoff_str\n            ]\n            \n            with open(metrics_path, 'w') as f:\n                json.dump({\n                    \"last_updated\": datetime.now().isoformat(),\n                    \"retention_days\": self.config.metrics_retention_days,\n                    \"metrics_count\": len(recent_metrics),\n                    \"metrics\": recent_metrics\n                }, f, indent=2)\n            \n            self.logger.debug(f\"Saved {len(recent_metrics)} metrics to {metrics_path}\")\n            \n        except Exception as error:\n            self.logger.error(f\"Failed to save metrics: {error}\")\n    \n    async def send_alert(self, alerts: List[Dict[str, Any]]):\n        \"\"\"Send alerts to webhook if configured\"\"\"\n        if not self.config.alert_webhook_url or not alerts:\n            return\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                payload = {\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"service\": \"cua_performance_monitor\",\n                    \"alerts\": alerts\n                }\n                \n                async with session.post(\n                    self.config.alert_webhook_url,\n                    json=payload,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    if response.status < 300:\n                        self.logger.info(f\"Sent {len(alerts)} alerts to webhook\")\n                    else:\n                        self.logger.warning(f\"Alert webhook returned status {response.status}\")\n        \n        except Exception as error:\n            self.logger.error(f\"Failed to send alerts: {error}\")\n    \n    async def monitoring_loop(self):\n        \"\"\"Main monitoring loop\"\"\"\n        self.logger.info(\"Starting monitoring loop\")\n        \n        while True:\n            try:\n                # Collect system metrics\n                metrics = await self.collect_system_metrics()\n                self.metrics_history.append(metrics)\n                \n                # Check service health\n                self.service_health = await self.check_service_health()\n                \n                # Check for alerts\n                alerts = await self.check_performance_alerts()\n                if alerts:\n                    self.logger.warning(f\"Performance alerts detected: {len(alerts)}\")\n                    await self.send_alert(alerts)\n                \n                # Save metrics periodically (every 10 monitoring cycles)\n                if len(self.metrics_history) % 10 == 0:\n                    await self.save_metrics()\n                \n                # Limit memory usage by keeping only recent metrics in memory\n                if len(self.metrics_history) > 1000:\n                    self.metrics_history = self.metrics_history[-500:]  # Keep last 500\n                \n                self.logger.debug(f\"Monitoring cycle completed - CPU: {metrics.cpu_usage:.1f}%, Memory: {metrics.memory_usage:.1f}%\")\n                \n            except Exception as error:\n                self.logger.error(f\"Error in monitoring loop: {error}\")\n            \n            await asyncio.sleep(self.config.monitor_interval)\n    \n    async def start(self):\n        \"\"\"Start the monitoring service\"\"\"\n        self.start_time = time.time()\n        self.logger.info(\"Starting C/ua Performance Monitor\")\n        \n        # Start monitoring loop in background\n        monitoring_task = asyncio.create_task(self.monitoring_loop())\n        \n        # Start FastAPI server\n        config = uvicorn.Config(\n            self.app,\n            host=\"0.0.0.0\",\n            port=self.config.port,\n            log_level=\"info\"\n        )\n        server = uvicorn.Server(config)\n        \n        # Run both monitoring and API server\n        try:\n            await asyncio.gather(\n                monitoring_task,\n                server.serve()\n            )\n        except KeyboardInterrupt:\n            self.logger.info(\"Shutting down monitoring service\")\n            monitoring_task.cancel()\n            await self.save_metrics()  # Save final metrics\n\n# === Main Entry Point ===\n\ndef main():\n    \"\"\"Main entry point for the performance monitor\"\"\"\n    parser = argparse.ArgumentParser(description=\"C/ua Performance Monitor\")\n    parser.add_argument(\"--config\", help=\"Configuration file path\")\n    parser.add_argument(\"--port\", type=int, default=9995, help=\"Port to run on\")\n    parser.add_argument(\"--log-file\", default=\"/opt/monitoring/logs/monitor.log\", help=\"Log file path\")\n    parser.add_argument(\"--monitor-interval\", type=int, default=10, help=\"Monitoring interval in seconds\")\n    args = parser.parse_args()\n    \n    # Create configuration\n    config = MonitorConfig(\n        port=args.port,\n        log_file=args.log_file,\n        monitor_interval=args.monitor_interval,\n        alert_webhook_url=os.getenv(\"ALERT_WEBHOOK_URL\")\n    )\n    \n    # Create and run monitor\n    monitor = PerformanceMonitor(config)\n    \n    try:\n        asyncio.run(monitor.start())\n    except KeyboardInterrupt:\n        print(\"\\nShutdown requested by user\")\n    except Exception as error:\n        print(f\"Fatal error: {error}\")\n        raise\n\nif __name__ == \"__main__\":\n    main()"

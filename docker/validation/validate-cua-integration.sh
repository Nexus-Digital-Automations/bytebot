#!/bin/bash\n\n# ==========================================\n# C/ua Framework Integration Validation Script\n# ==========================================\n# Comprehensive validation and testing suite for C/ua-enabled Bytebot container\n# Tests: Docker build, service startup, API endpoints, performance metrics\n\nset -euo pipefail\n\n# === Configuration ===\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nPROJECT_ROOT=\"$(cd \"$SCRIPT_DIR/../..\" && pwd)\"\nLOG_FILE=\"$PROJECT_ROOT/logs/validation-$(date +%Y%m%d-%H%M%S).log\"\nVALIDATION_TIMEOUT=300  # 5 minutes\nCOMPOSE_FILE=\"$PROJECT_ROOT/docker/docker-compose-cua.yml\"\nANE_BRIDGE_URL=\"http://host.docker.internal:8080\"\n\n# === Colors for Output ===\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# === Logging Functions ===\nlog_message() {\n    local level=\"$1\"\n    local message=\"$2\"\n    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n    echo -e \"[${timestamp}] [${level}] ${message}\" | tee -a \"$LOG_FILE\"\n}\n\nlog_info() {\n    log_message \"INFO\" \"${BLUE}$1${NC}\"\n}\n\nlog_success() {\n    log_message \"SUCCESS\" \"${GREEN}✓ $1${NC}\"\n}\n\nlog_warning() {\n    log_message \"WARNING\" \"${YELLOW}⚠ $1${NC}\"\n}\n\nlog_error() {\n    log_message \"ERROR\" \"${RED}✗ $1${NC}\"\n}\n\n# === Validation Functions ===\n\nvalidate_prerequisites() {\n    log_info \"Validating prerequisites\"\n    \n    # Check if Docker is running\n    if ! docker info > /dev/null 2>&1; then\n        log_error \"Docker is not running or not accessible\"\n        return 1\n    fi\n    log_success \"Docker is running\"\n    \n    # Check if docker-compose is available\n    if ! command -v docker-compose > /dev/null 2>&1; then\n        log_error \"docker-compose is not installed\"\n        return 1\n    fi\n    log_success \"docker-compose is available\"\n    \n    # Check if compose file exists\n    if [ ! -f \"$COMPOSE_FILE\" ]; then\n        log_error \"Compose file not found: $COMPOSE_FILE\"\n        return 1\n    fi\n    log_success \"Compose file exists\"\n    \n    # Check if curl is available\n    if ! command -v curl > /dev/null 2>&1; then\n        log_error \"curl is not installed (required for API testing)\"\n        return 1\n    fi\n    log_success \"curl is available\"\n    \n    # Check available disk space (need at least 2GB)\n    local available_space\n    available_space=$(df . | tail -1 | awk '{print $4}')\n    if [ \"$available_space\" -lt 2097152 ]; then  # 2GB in KB\n        log_warning \"Low disk space detected (less than 2GB available)\"\n    else\n        log_success \"Sufficient disk space available\"\n    fi\n    \n    return 0\n}\n\nvalidate_docker_build() {\n    log_info \"Validating Docker build process\"\n    \n    local dockerfile_path=\"$PROJECT_ROOT/docker/bytebot-desktop.Dockerfile\"\n    \n    # Check if Dockerfile exists\n    if [ ! -f \"$dockerfile_path\" ]; then\n        log_error \"Dockerfile not found: $dockerfile_path\"\n        return 1\n    fi\n    log_success \"Dockerfile exists\"\n    \n    # Validate Dockerfile syntax (basic check)\n    if ! docker build --dry-run -f \"$dockerfile_path\" \"$PROJECT_ROOT/docker\" > /dev/null 2>&1; then\n        log_error \"Dockerfile has syntax errors\"\n        return 1\n    fi\n    log_success \"Dockerfile syntax is valid\"\n    \n    # Check for C/ua framework components in Dockerfile\n    if grep -q \"CUA_FRAMEWORK_ENABLED\" \"$dockerfile_path\"; then\n        log_success \"C/ua framework configuration found in Dockerfile\"\n    else\n        log_warning \"C/ua framework configuration not found in Dockerfile\"\n    fi\n    \n    # Check for required C/ua directories\n    if grep -q \"/opt/cua\" \"$dockerfile_path\"; then\n        log_success \"C/ua directories configured in Dockerfile\"\n    else\n        log_warning \"C/ua directories not found in Dockerfile\"\n    fi\n    \n    return 0\n}\n\nstart_services() {\n    log_info \"Starting C/ua-enabled services\"\n    \n    # Clean up any existing containers\n    log_info \"Cleaning up existing containers\"\n    docker-compose -f \"$COMPOSE_FILE\" down --remove-orphans > /dev/null 2>&1 || true\n    \n    # Start services with build\n    log_info \"Building and starting services (this may take several minutes)\"\n    if ! timeout $VALIDATION_TIMEOUT docker-compose -f \"$COMPOSE_FILE\" up -d --build; then\n        log_error \"Failed to start services within $VALIDATION_TIMEOUT seconds\"\n        return 1\n    fi\n    \n    log_success \"Services started successfully\"\n    \n    # Wait for services to be ready\n    log_info \"Waiting for services to be ready\"\n    sleep 30  # Give services time to initialize\n    \n    return 0\n}\n\nwait_for_service() {\n    local service_name=\"$1\"\n    local service_url=\"$2\"\n    local timeout=\"${3:-60}\"\n    \n    log_info \"Waiting for $service_name to be ready at $service_url\"\n    \n    local count=0\n    while [ $count -lt $timeout ]; do\n        if curl -s --max-time 5 \"$service_url\" > /dev/null 2>&1; then\n            log_success \"$service_name is ready\"\n            return 0\n        fi\n        \n        sleep 2\n        count=$((count + 2))\n    done\n    \n    log_error \"$service_name failed to become ready within $timeout seconds\"\n    return 1\n}\n\nvalidate_service_endpoints() {\n    log_info \"Validating service endpoints\"\n    \n    local validation_errors=0\n    \n    # Test original Bytebot service\n    log_info \"Testing original Bytebot service\"\n    if wait_for_service \"Bytebot Desktop\" \"http://localhost:9990\" 60; then\n        log_success \"Bytebot Desktop service is accessible\"\n    else\n        log_error \"Bytebot Desktop service is not accessible\"\n        validation_errors=$((validation_errors + 1))\n    fi\n    \n    # Test C/ua Agent API\n    log_info \"Testing C/ua Agent API\"\n    if wait_for_service \"C/ua Agent API\" \"http://localhost:9993/api/v1/health\" 60; then\n        log_success \"C/ua Agent API is accessible\"\n    else\n        log_error \"C/ua Agent API is not accessible\"\n        validation_errors=$((validation_errors + 1))\n    fi\n    \n    # Test Performance Monitor\n    log_info \"Testing Performance Monitor\"\n    if wait_for_service \"Performance Monitor\" \"http://localhost:9995/health\" 60; then\n        log_success \"Performance Monitor is accessible\"\n    else\n        log_warning \"Performance Monitor is not accessible (non-critical)\"\n    fi\n    \n    # Test WebSocket Server\n    log_info \"Testing WebSocket Server\"\n    if wait_for_service \"WebSocket Server\" \"http://localhost:9996/health\" 30; then\n        log_success \"WebSocket Server is accessible\"\n    else\n        log_warning \"WebSocket Server is not accessible (non-critical)\"\n    fi\n    \n    return $validation_errors\n}\n\nvalidate_cua_integration() {\n    log_info \"Validating C/ua framework integration\"\n    \n    local integration_errors=0\n    \n    # Test C/ua status endpoint\n    log_info \"Testing C/ua status endpoint\"\n    local status_response\n    if status_response=$(curl -s --max-time 10 \"http://localhost:9993/api/v1/cua/status\" 2>/dev/null); then\n        log_success \"C/ua status endpoint responded\"\n        \n        # Check if response contains expected C/ua data\n        if echo \"$status_response\" | grep -q '\"framework\"'; then\n            log_success \"C/ua framework status data found\"\n        else\n            log_error \"C/ua framework status data missing\"\n            integration_errors=$((integration_errors + 1))\n        fi\n        \n        # Check ANE bridge status\n        if echo \"$status_response\" | grep -q '\"bridge\"'; then\n            log_success \"ANE bridge status data found\"\n        else\n            log_warning \"ANE bridge status data missing (expected if bridge not running)\"\n        fi\n        \n    else\n        log_error \"C/ua status endpoint not accessible\"\n        integration_errors=$((integration_errors + 1))\n    fi\n    \n    # Test C/ua capabilities endpoint\n    log_info \"Testing C/ua capabilities endpoint\"\n    if curl -s --max-time 10 \"http://localhost:9993/api/v1/cua/capabilities\" > /dev/null 2>&1; then\n        log_success \"C/ua capabilities endpoint responded\"\n    else\n        log_error \"C/ua capabilities endpoint not accessible\"\n        integration_errors=$((integration_errors + 1))\n    fi\n    \n    # Test enhanced computer-use endpoints\n    log_info \"Testing enhanced computer-use endpoints\"\n    local screenshot_response\n    if screenshot_response=$(curl -s --max-time 15 -X POST \"http://localhost:9990/computer-use\" \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\"action\": \"screenshot\"}' 2>/dev/null); then\n        \n        if echo \"$screenshot_response\" | grep -q '\"image\"'; then\n            log_success \"Enhanced screenshot endpoint working\"\n        else\n            log_error \"Screenshot endpoint response missing image data\"\n            integration_errors=$((integration_errors + 1))\n        fi\n    else\n        log_error \"Screenshot endpoint not accessible\"\n        integration_errors=$((integration_errors + 1))\n    fi\n    \n    return $integration_errors\n}\n\nvalidate_performance_metrics() {\n    log_info \"Validating performance metrics collection\"\n    \n    # Test performance metrics endpoint\n    local metrics_response\n    if metrics_response=$(curl -s --max-time 10 \"http://localhost:9995/metrics\" 2>/dev/null); then\n        log_success \"Performance metrics endpoint accessible\"\n        \n        # Check for expected metric fields\n        if echo \"$metrics_response\" | grep -q '\"cpu_usage\"'; then\n            log_success \"CPU usage metrics found\"\n        else\n            log_warning \"CPU usage metrics missing\"\n        fi\n        \n        if echo \"$metrics_response\" | grep -q '\"memory_usage\"'; then\n            log_success \"Memory usage metrics found\"\n        else\n            log_warning \"Memory usage metrics missing\"\n        fi\n        \n    else\n        log_warning \"Performance metrics endpoint not accessible (non-critical)\"\n    fi\n    \n    # Test service health endpoint\n    if curl -s --max-time 10 \"http://localhost:9995/services\" > /dev/null 2>&1; then\n        log_success \"Service health monitoring accessible\"\n    else\n        log_warning \"Service health monitoring not accessible (non-critical)\"\n    fi\n    \n    return 0\n}\n\nvalidate_container_health() {\n    log_info \"Validating container health status\"\n    \n    # Get container status\n    local containers\n    containers=$(docker-compose -f \"$COMPOSE_FILE\" ps --services 2>/dev/null || true)\n    \n    if [ -z \"$containers\" ]; then\n        log_error \"No containers found\"\n        return 1\n    fi\n    \n    local unhealthy_containers=0\n    \n    for service in $containers; do\n        local status\n        status=$(docker-compose -f \"$COMPOSE_FILE\" ps \"$service\" --format \"table {{.State}}\" 2>/dev/null | tail -n +2 | head -n 1)\n        \n        if [ \"$status\" = \"running\" ] || [ \"$status\" = \"Up\" ]; then\n            log_success \"Container $service is running\"\n        else\n            log_error \"Container $service is not running (status: $status)\"\n            unhealthy_containers=$((unhealthy_containers + 1))\n        fi\n    done\n    \n    # Check container health checks if available\n    log_info \"Checking container health status\"\n    local health_status\n    health_status=$(docker-compose -f \"$COMPOSE_FILE\" ps --format \"table {{.Service}} {{.Health}}\" 2>/dev/null || true)\n    \n    if [ -n \"$health_status\" ]; then\n        echo \"$health_status\" | tail -n +2 | while read -r service health; do\n            if [ \"$health\" = \"healthy\" ]; then\n                log_success \"Container $service is healthy\"\n            elif [ \"$health\" = \"starting\" ]; then\n                log_info \"Container $service is starting\"\n            elif [ -n \"$health\" ] && [ \"$health\" != \"\" ]; then\n                log_warning \"Container $service health: $health\"\n            fi\n        done\n    fi\n    \n    return $unhealthy_containers\n}\n\ngenerate_validation_report() {\n    log_info \"Generating validation report\"\n    \n    local report_file=\"$PROJECT_ROOT/logs/cua-validation-report-$(date +%Y%m%d-%H%M%S).json\"\n    \n    cat > \"$report_file\" << EOF\n{\n  \"validation_timestamp\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\",\n  \"validation_duration_seconds\": $(($(date +%s) - validation_start_time)),\n  \"validation_results\": {\n    \"overall_status\": \"$validation_status\",\n    \"prerequisites_passed\": $prerequisites_passed,\n    \"docker_build_passed\": $docker_build_passed,\n    \"services_started\": $services_started,\n    \"endpoints_validated\": $endpoints_validated,\n    \"cua_integration_validated\": $cua_integration_validated,\n    \"performance_metrics_validated\": $performance_metrics_validated,\n    \"container_health_validated\": $container_health_validated\n  },\n  \"service_endpoints\": {\n    \"bytebot_desktop\": \"http://localhost:9990\",\n    \"cua_agent_api\": \"http://localhost:9993\",\n    \"performance_monitor\": \"http://localhost:9995\",\n    \"websocket_server\": \"http://localhost:9996\"\n  },\n  \"validation_log\": \"$LOG_FILE\"\n}\nEOF\n    \n    log_success \"Validation report saved to: $report_file\"\n}\n\ncleanup_services() {\n    log_info \"Cleaning up test services\"\n    \n    if [ \"${CLEANUP_ON_EXIT:-true}\" = \"true\" ]; then\n        docker-compose -f \"$COMPOSE_FILE\" down --remove-orphans > /dev/null 2>&1 || true\n        log_success \"Test services cleaned up\"\n    else\n        log_info \"Skipping cleanup (CLEANUP_ON_EXIT=false)\"\n        log_info \"To manually clean up: docker-compose -f $COMPOSE_FILE down\"\n    fi\n}\n\n# === Signal Handling ===\ncleanup_on_exit() {\n    log_info \"Validation interrupted - performing cleanup\"\n    cleanup_services\n    exit 1\n}\n\ntrap cleanup_on_exit INT TERM\n\n# === Main Validation Process ===\n\nmain() {\n    local validation_start_time=$(date +%s)\n    local validation_status=\"unknown\"\n    local prerequisites_passed=false\n    local docker_build_passed=false\n    local services_started=false\n    local endpoints_validated=false\n    local cua_integration_validated=false\n    local performance_metrics_validated=false\n    local container_health_validated=false\n    \n    # Create logs directory\n    mkdir -p \"$PROJECT_ROOT/logs\"\n    \n    log_info \"=== Starting C/ua Framework Integration Validation ===\"\n    log_info \"Project Root: $PROJECT_ROOT\"\n    log_info \"Compose File: $COMPOSE_FILE\"\n    log_info \"Log File: $LOG_FILE\"\n    \n    # Step 1: Prerequisites\n    if validate_prerequisites; then\n        prerequisites_passed=true\n    else\n        validation_status=\"failed\"\n        log_error \"Prerequisites validation failed\"\n        return 1\n    fi\n    \n    # Step 2: Docker Build\n    if validate_docker_build; then\n        docker_build_passed=true\n    else\n        validation_status=\"failed\"\n        log_error \"Docker build validation failed\"\n        return 1\n    fi\n    \n    # Step 3: Start Services\n    if start_services; then\n        services_started=true\n    else\n        validation_status=\"failed\"\n        log_error \"Service startup failed\"\n        cleanup_services\n        return 1\n    fi\n    \n    # Step 4: Validate Service Endpoints\n    if validate_service_endpoints; then\n        endpoints_validated=true\n    else\n        validation_status=\"failed\"\n        log_error \"Service endpoint validation failed\"\n    fi\n    \n    # Step 5: Validate C/ua Integration\n    if validate_cua_integration; then\n        cua_integration_validated=true\n    else\n        validation_status=\"failed\"\n        log_error \"C/ua integration validation failed\"\n    fi\n    \n    # Step 6: Validate Performance Metrics\n    if validate_performance_metrics; then\n        performance_metrics_validated=true\n    fi\n    \n    # Step 7: Validate Container Health\n    if validate_container_health; then\n        container_health_validated=true\n    else\n        validation_status=\"failed\"\n        log_error \"Container health validation failed\"\n    fi\n    \n    # Determine overall validation status\n    if [ \"$validation_status\" != \"failed\" ]; then\n        if [ \"$endpoints_validated\" = \"true\" ] && [ \"$cua_integration_validated\" = \"true\" ]; then\n            validation_status=\"passed\"\n            log_success \"=== C/ua Framework Integration Validation PASSED ===\"\n        else\n            validation_status=\"partial\"\n            log_warning \"=== C/ua Framework Integration Validation PARTIALLY PASSED ===\"\n        fi\n    else\n        log_error \"=== C/ua Framework Integration Validation FAILED ===\"\n    fi\n    \n    # Generate report\n    generate_validation_report\n    \n    # Cleanup\n    cleanup_services\n    \n    # Exit with appropriate code\n    case \"$validation_status\" in\n        \"passed\")\n            return 0\n            ;;\n        \"partial\")\n            return 2\n            ;;\n        *)\n            return 1\n            ;;\n    esac\n}\n\n# Parse command line arguments\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --no-cleanup)\n            export CLEANUP_ON_EXIT=false\n            shift\n            ;;\n        --timeout)\n            VALIDATION_TIMEOUT=\"$2\"\n            shift 2\n            ;;\n        --help)\n            echo \"Usage: $0 [OPTIONS]\"\n            echo \"Options:\"\n            echo \"  --no-cleanup     Don't clean up containers after validation\"\n            echo \"  --timeout SECS   Set timeout for service startup (default: 300)\"\n            echo \"  --help          Show this help message\"\n            exit 0\n            ;;\n        *)\n            log_error \"Unknown option: $1\"\n            exit 1\n            ;;\n    esac\ndone\n\n# Run main validation\nmain \"$@\""